---
title: "Model Summary"
output: "pdf_document"
---

```{r, include=FALSE}
library(reticulate)
library(tidyverse)

# python doesn't know how to read the snakemake object, so give it a little bump
ebm <- snakemake@input[["model"]]
test_x <- snakemake@input[["test_x"]]
test_y <- snakemake@input[["test_y"]]
```

```{python, include = FALSE}
import pickle 
import pandas as pd
import numpy as np
from dash import html
from sklearn import metrics
from sklearn.model_selection import train_test_split
from interpret import set_visualize_provider
from interpret.provider import InlineProvider
from interpret.glassbox import ExplainableBoostingClassifier
from interpret import show

def read_pickle(path):
    with open(path, 'rb') as f:
        return pickle.load(f)
    
ebm = read_pickle(r.ebm)
X_test = read_pickle(r.test_x)
y_test = read_pickle(r.test_y)

```

# Model Statistics

```{python, include = FALSE}

def format_metric(x):
    return "%.2f%%" % (100 * x)

accuracy = format_metric(ebm.score(X_test, y_test))

y_pred = ebm.predict_proba(X_test)[::, 1]
report = metrics.classification_report(
    (y_test == "tp").astype(int),
    y_pred > 0.5,
    target_names = ["fp", "tp"],
    output_dict = True,
)
rtp = report["tp"]
precision = format_metric(rtp["precision"])
recall = format_metric(rtp["recall"])
f1 = format_metric(rtp["f1-score"])

```

- Accuracy: `r py$accuracy`
- Precision: `r py$precision`
- Recall: `r py$recall`
- F1: `r py$f1`

## ROC Curve

```{python, include = FALSE}
import matplotlib.pyplot as plt

auc = format_metric(metrics.roc_auc_score(y_test, y_pred))
fpr, tpr, _ = metrics.roc_curve(y_test, y_pred, pos_label = "tp")
auc_data = pd.DataFrame({"fpr": fpr, "tpr": tpr})

```

AUC: `r py$auc`

```{r, echo = FALSE}
# use ggplot since matplotlib seems to ignore where rmarkdown tells it to go
ggplot(py$auc_data, aes(fpr, tpr)) +
    geom_line() +
    scale_x_continuous(name = "Specificity", limits = c(0, 1)) +
    scale_y_continuous(name = "Sensitivity", limits = c(0, 1))
```

# Global Score Plot

```{python, include = FALSE}
ebm_global = ebm.explain_global()

def get_plot_dict(global_data):
    return {
        k: v
        for k, v in global_data.items()
        if k in ["names", "scores"]
    }

global_df = pd.DataFrame(get_plot_dict(ebm_global.data()))

```

```{r, echo = FALSE}
ggplot(py$global_df, aes(scores, reorder(names, scores))) +
    geom_col() +
    xlab("Score") +
    ylab(NULL)

```

# Univariate plots

```{python, include = FALSE}

def array_repeat_last(arr):
    return np.append(arr, [arr[-1]])

def feature_plot_dict(vartype, feature_data):
    if vartype == "continuous":
        return {
            k: array_repeat_last(v) if k == "scores" else v
            for k, v in feature_data.items()
            if k in ["names", "scores"]
        }
    elif vartype == "categorical":
        return get_plot_dict(feature_data)
    else:
        assert False ("wrong vartype, dummy: %s" % vartype)

all_features = {
    n: (t, i)
    for i, (n, t) in enumerate(
            map(tuple, ebm_global.selector[["Name", "Type"]].to_numpy())
    )
}

univariate_dfs = {
    name: (vartype, pd.DataFrame(feature_plot_dict(vartype, ebm_global.data(i))))
    for name, (vartype, i) in all_features.items()
    if vartype in ["continuous", "categorical"]
}

```

```{r, echo = FALSE, results = "asis", fig.width = 6, fig.height = 3}

make_continuous_plot <- function(df, name) {
    ggplot(df, aes(names, scores)) +
        geom_step() +
        xlab(name) +
        ylab("Score")
}

make_categorical_plot <- function(df, name) {
    ggplot(df, aes(factor(names), scores)) +
        geom_col() +
        xlab(name) +
        ylab("Score")
}

print_uv_plot <- function(vartype, df, name) {
    if (vartype == "continuous") {
        p <- make_continuous_plot(df, name)
    } else if (vartype == "categorical") {
        p <- make_categorical_plot(df, name)
    } else {
        p <- sprintf("wrong plot type, dummy; got %s", vartype)
    }

    cat(sprintf("## %s\n", name))
    print(p)
    cat("\n\n")
}

iwalk(py$univariate_dfs, ~ print_uv_plot(.x[[1]], py_to_r(.x[[2]]), .y))

```

# Bivariate plots

```{python, include = FALSE}

def lookup_feature_type(name):
    return all_features[name][0]

def build_scores_array(arr, left_type, right_type):
    # any continuous dimension is going to be one less than the names length,
    # so copy the last row/column to the end in these cases
    if left_type == "continuous":
        arr = np.vstack((arr, arr[-1, :]))
    if right_type == "continuous":
        arr = np.column_stack((arr, arr[:, -1]))
    return arr

def interaction_plot_df(name, data_index):
    feature_data = ebm_global.data(data_index)
    # left is first dimension, right is second
    left_name, right_name = tuple(name.split(" x "))

    left_type = lookup_feature_type(left_name)
    right_type = lookup_feature_type(right_name)

    left_index = pd.Index(feature_data["left_names"], name = "left")
    right_index = pd.Index(feature_data["right_names"], name = "right")

    arr = build_scores_array(feature_data["scores"], left_type, right_type)
    df = (
        pd.DataFrame(arr, index = left_index, columns = right_index)
        .stack()
        .rename("score")
        .reset_index()
    )

    return {
        "left": {
            "name": left_name,
            "type": left_type
        },
        "right": {
            "name": right_name,
            "type": right_type
        },
        "df": df,
    }
    
bivariate_dfs = {
    name: interaction_plot_df(name, i)
    for name, (vartype, i) in all_features.items()
    if vartype == "interaction"
}

```

```{r, echo = FALSE, results = "asis", fig.width = 6, fig.height = 3.5}

cont_cont_plot <- function(df, left_name, right_name) {
    # poor-mans 2d step heatmap plot thing
    df %>%
        group_by(right) %>%
        mutate(left_upper = lead(left)) %>%
        ungroup() %>%
        group_by(left) %>%
        mutate(right_upper = lead(right)) %>%
        ungroup() %>%
        filter(!is.na(left_upper)) %>%
        filter(!is.na(right_upper)) %>%
        ggplot() +
        geom_rect(aes(xmin = left,
                      xmax = left_upper,
                      ymin = right,
                      ymax = right_upper,
                      fill = score)) +
        xlab(left_name) +
        ylab(right_name) +
        scale_fill_gradient2(low = "red",
                             mid = "black",
                             high = "green",
                             midpoint = 0)
}

cont_cat_plot <- function(df, cat, cont, cat_name, cont_name) {
    ggplot(df, aes_string(cont, "score", color = factor(cat))) +
        geom_step() +
        xlab(cont_name) +
        scale_fill_discrete(name = cat_name)
}

cat_cat_plot <- function(df, left_name, right_name) {
    ggplot(df, aes(left, score, fill = factor(right))) +
        geom_col(position = "dodge") +
        xlab(left_name) +
        scale_fill_discrete(name = right_name)
}

print_bv_plot <- function(L, R, df) {
    .df <- py_to_r(df)

    if (L$type == "continuous" && R$type == "continuous") {
        p <- cont_cont_plot(.df, L$name, R$name)
    } else if (L$type == "categorical" && R$type == "continuous") {
        p <- cont_cat_plot(.df, "left", "right", L$name, R$name)
    } else if (L$type == "continuous" && R$type == "categorical") {
        p <- cont_cat_plot(.df, "right", "left", R$name, L$name)
    } else if (L$type == "categorical" && R$type == "categorical") {
        p <- cat_cat_plot(.df, R$name, L$name)
    } else {
        p <- sprintf("Types are wrong, dummy: %s and/or %s", L$type, R$type)
    }
    cat(sprintf("## %s x %s\n\n", L$name, R$name))
    print(p)
    cat("\n\n")
}

dfs <- py$bivariate_dfs

if (length(dfs) == 0) {
    cat("None\n\n")
} else {
    walk(dfs, ~ print_bv_plot(.x[["left"]], .x[["right"]], .x[["df"]]))
}

```
