---
title: "Model Summary"
output: "pdf_document"
---

```{r, include=FALSE}
library(reticulate)
library(tidyverse)

# python doesn't know how to read the snakemake object, so give it a little bump
ebm <- snakemake@input[["model"]]
test_x <- snakemake@input[["test_x"]]
test_y <- snakemake@input[["test_y"]]
```

```{python, include = FALSE}
import pickle 
import pandas as pd
import numpy as np
from dash import html
from sklearn import metrics
from sklearn.model_selection import train_test_split
from interpret import set_visualize_provider
from interpret.provider import InlineProvider
from interpret.glassbox import ExplainableBoostingClassifier
from interpret import show

def read_pickle(path):
    with open(path, 'rb') as f:
        return pickle.load(f)
    
ebm = read_pickle(r.ebm)
X_test = read_pickle(r.test_x)
y_test = read_pickle(r.test_y)

```

# Model Statistics

```{python, include = FALSE}

def format_metric(x):
    return "%.2f%%" % (100 * x)

accuracy = format_metric(ebm.score(X_test, y_test))

y_pred = ebm.predict_proba(X_test)[::, 1]
report = metrics.classification_report(
    (y_test == "tp").astype(int),
    y_pred > 0.5,
    target_names = ["fp", "tp"],
    output_dict = True,
)
rtp = report["tp"]
precision = format_metric(rtp["precision"])
recall = format_metric(rtp["recall"])
f1 = format_metric(rtp["f1-score"])

```

- Accuracy: `r py$accuracy`
- Precision: `r py$precision`
- Recall: `r py$recall`
- F1: `r py$f1`

## ROC Curve

```{python, include = FALSE}
import matplotlib.pyplot as plt

auc = format_metric(metrics.roc_auc_score(y_test, y_pred))
fpr, tpr, _ = metrics.roc_curve(y_test, y_pred, pos_label = "tp")
auc_data = pd.DataFrame({"fpr": fpr, "tpr": tpr})

```

AUC: `r py$auc`

```{r, echo = FALSE}
# use ggplot since matplotlib seems to ignore where rmarkdown tells it to go
ggplot(py$auc_data, aes(fpr, tpr)) +
    geom_line() +
    scale_x_continuous(name = "Specificity", limits = c(0, 1)) +
    scale_y_continuous(name = "Sensitivity", limits = c(0, 1))
```

# Global Score Plot

```{python, include = FALSE}
ebm_global = ebm.explain_global()

def get_plot_dict(global_data):
    return {
        k: v
        for k, v in global_data.items()
        if k in ["names", "scores"]
    }

global_df = pd.DataFrame(get_plot_dict(ebm_global.data()))

```

```{r, echo = FALSE}
ggplot(py$global_df, aes(scores, reorder(names, scores))) +
    geom_col() +
    xlab("Score") +
    ylab(NULL)

```

# Univariate plots

```{python, include = FALSE}

def array_repeat_last(arr):
    return np.append(arr, [arr[-1]])

def feature_plot_dict(vartype, feature_data):
    if vartype == "continuous":
        return {
            k: array_repeat_last(v) if k == "scores" else v
            for k, v in feature_data.items()
            if k in ["names", "scores"]
        }
    elif vartype == "categorical":
        return get_plot_dict(feature_data)
    # TODO add interactions
    else:
        assert False ("wrong vartype, dummy: %s" % vartype)

sel = ebm_global.selector

feature_dfs = {
    n: (t, pd.DataFrame(feature_plot_dict(t, ebm_global.data(i))))
    for i, (n, t) in enumerate(map(tuple, sel[["Name", "Type"]].to_numpy()))
    if t in ["continuous", "categorical"]
}

```

```{r, echo = FALSE, results = "asis", fig.width = 6, fig.height = 3}

make_continuous_plot <- function(df, name) {
    ggplot(df, aes(names, scores)) +
        geom_step() +
        xlab(name) +
        ylab("Score")
}

make_categorical_plot <- function(df, name) {
    ggplot(df, aes(factor(names), scores)) +
        geom_col() +
        xlab(name) +
        ylab("Score")
}

print_plot <- function(vartype, df, name) {
    if (vartype == "continuous") {
        p <- make_continuous_plot(df, name)
    } else if (vartype == "categorical") {
        p <- make_categorical_plot(df, name)
    } else {
        p <- sprintf("wrong plot type, dummy; got %s", vartype)
    }

    cat(sprintf("## %s\n", name))
    print(p)
    cat("\n\n")
}

iwalk(py$feature_dfs, ~ print_plot(.x[[1]], py_to_r(.x[[2]]), .y))

```
