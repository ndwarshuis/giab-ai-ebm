---
title: "Model Summary"
output: "html_document"
---

```{r, include=FALSE, message=FALSE}
library(tidyverse)
library(ggpubr)

source("workflow/scripts/rmarkdown/common/plots.r")

to_tibble <- function(lst) {
    do.call(tibble, lst)
}

get_run_features <- function(wildcards, config) {
    run_key <- wildcards[["run_key"]]
    config[["ebm_runs"]][[run_key]][["features"]]
}

read_model <- function(path) {
    jsonlite::read_json(path, simplifyVector = TRUE, simplifyDataFrame = FALSE)
}

read_predictions <- function(path) {
    readr::read_csv(path, col_types = cols(.default = "d"))
}

read_input_paths <- function(path) {
    jsonlite::read_json(path) %>%
        set_names(~ basename(dirname(.x)))
}

lookup_input_path <- function(mapping, k) {
    pluck(mapping, as.character(as.integer(k)))
}

to_univariate <- function(model) {
    model$univariate %>%
        map(~ list(meta = .x[c("name", "vartype")], df = to_tibble(.x[["df"]])))
}

to_bivariate <- function(model) {
    model$bivariate %>%
        map(~ list(left = .x$left, right = .x$right, df = to_tibble(.x$df)))
}

run_features <- get_run_features(snakemake@wildcards, snakemake@config)

mod <- read_model(snakemake@input[["model"]])
ypred <- read_predictions(snakemake@input[["predictions"]])
input_keys <- read_input_paths(snakemake@input[["paths"]])

VCF_input_name <- "VCF_input"

global_df <- to_tibble(mod$global)

univariate <- to_univariate(mod)
bivariate <- to_bivariate(mod)

```

# Model Statistics

## Input file keys:

```{r, echo = F, results = "asis"}

iwalk(input_keys, ~ cat(sprintf("- %d: %s\n", .x, .y)))
cat("\n")

```

## Overview

* N: `r nrow(ypred)`
* Perc. Pos: `r sum(ypred$label)/nrow(ypred)`

## Prediction Distribution

```{r, echo = FALSE, results = "asis", fig.width = 7, fig.height = 4}
ggplot(ypred, aes(prob, color = factor(label))) +
    geom_density() +
    xlab("probability") +
    scale_color_discrete(name = "label")
```

## ROC Curve

```{r, include=FALSE}

AllP <- sum(ypred$label)
AllN <- nrow(ypred) - AllP

roc <- ypred %>%
    arrange(prob) %>%
    mutate(thresh_FN = cumsum(label),
           thresh_TN = row_number() - thresh_FN,
           thresh_TP = AllP - thresh_FN,
           thresh_FP = AllN - thresh_TN,
           TPR = thresh_TP / AllP,
           TNR = thresh_TN / AllN,
           FPR = 1 - TNR,
           precision = thresh_TP / (thresh_TP + thresh_FP))

```

```{r, echo = FALSE, results = "asis", fig.width = 4, fig.height = 4}
roc %>%
    arrange(FPR, TPR) %>%
    ggplot(aes(FPR, TPR)) +
    geom_line()

roc %>%
    filter(!is.na(precision)) %>%
    arrange(TPR, desc(precision)) %>%
    ggplot(aes(TPR, precision)) +
    geom_line()
```

# Global Score Plot


```{r, echo = FALSE}
ggplot(global_df, aes(score, reorder(variable, score))) +
    geom_col() +
    xlab("Score") +
    ylab(NULL)

```

# Univariate plots

```{r, echo = FALSE, results = "asis", fig.width = 8, fig.height = 4}

get_truncation <- function(s) {
    run_features[[s]][["visualization"]][["truncate"]]
}

get_split_missing <- function(s) {
    run_features[[s]][["visualization"]][["split_missing"]]
}

get_fill_na <- function(s) {
    run_features[[s]][["fill_na"]]
}

get_plot_type <- function(s) {
    run_features[[s]][["visualization"]][["plot_type"]]
}

truncate_maybe <- function(df, name) {
    t <- get_truncation(name)
    lower <- t[["lower"]]
    upper <- t[["upper"]]
    caption <- if (!is.null(lower) && !is.null(upper)) {
                   sprintf("Truncated from %d to %d", lower, upper)
               } else if (!is.null(lower)) {
                   sprintf("Truncated from %d to -Inf", lower)
               } else if (!is.null(upper)) {
                   sprintf("Truncated from -Inf to %d", upper)
               }
    .df <- if (is.null(lower) && is.null(upper)) {
               df
           } else {
               .lower <- if (is.null(lower)) min(df$value) else lower
               .upper <- if (is.null(upper)) max(df$value) else upper
               filter(df, .lower <= value & value <= .upper)
           }
    list(df = .df, lower = lower, upper = upper, caption = caption)
}

make_integer_plot <- function(df, name, lower = NULL, upper = NULL,
                              caption = NULL, ylab = "Score") {
    fill_cols <- c("score", "stdev")
    .lower <- if (is.null(lower)) min(df$value) else lower
    .upper <- if (is.null(upper)) max(df$value) else upper
    .join <- tibble(value = .lower:.upper)
    .df <- mutate(df, value = ceiling(value)) %>%
        right_join(.join, by = "value") %>%
        arrange(value) %>%
        fill(all_of(fill_cols), .direction = "downup")
    p <- ggplot(.df, aes(value, score)) +
        geom_col() +
        xlab(name) +
        ylab(ylab) +
        geom_errorbar(aes(ymin = score - stdev, ymax = score + stdev))
    if (is.null(caption)) p else p + labs(caption = caption)
}

make_continuous_plot <- function(df, name, caption = NULL, ylab = "Score") {
    p <- ggplot(df, aes(value, score)) +
        geom_step(aes(y = score + stdev), color = "red") +
        geom_step(aes(y = score - stdev), color = "red") +
        geom_step() +
        xlab(name) +
        ylab(ylab)
    if (is.null(caption)) p else p + labs(caption = caption)
}

make_categorical_plot <- function(df, name, ylab = "Score") {
    ggplot(df, aes(factor(value), score)) +
        geom_col() +
        geom_errorbar(aes(ymin = score - stdev, ymax = score + stdev), width = 0.1) +
        xlab(name) +
        ylab(ylab)
}

make_split_plot <- function(df, name, bound, fun) {
    missing_val <- get_fill_na(name)
    bounds <- df %>%
        mutate(lower = score - stdev,
               upper = score + stdev) %>%
        summarize(maxvalue = max(upper),
                  minvalue = min(lower))
    missing <- filter(df, value == missing_val) %>%
        mutate(value = "Missing")
    nonmissing <- filter(df, value != missing_val) %>%
        mutate(value = if_else(value < bound, bound, value))
    yaxis <- scale_y_continuous(limits = c(bounds$minvalue, bounds$maxvalue))
    bar <- ggplot(missing, aes(factor(value), score)) +
        geom_col() +
        geom_errorbar(aes(ymax = score + stdev,
                          ymin = score - stdev),
                      width = 0.2) +
        xlab(NULL) +
        yaxis
    step <- fun(nonmissing, NULL) +
        yaxis +
        theme(axis.text.y = element_blank(),
              axis.ticks.y = element_blank())
    ggarrange(bar, step, ncol = 2, widths = c(1, 5)) %>%
        annotate_figure(bottom = text_grob(name))
}

wrap_split_maybe <- function(name, f) {
    s <- get_split_missing(name)
    f
    if (is.null(s)) f else partial(make_split_plot, fun = f, bound = s)
}

print_uv_plot <- function(vartype, df, name) {
    r <- if (vartype == "continuous") {
             tr <- truncate_maybe(df, name)
             t <- get_plot_type(name)
             f <- if (t == "step") {
                      partial(make_continuous_plot, caption = tr[["caption"]])
                  } else if (t == "bar") {
                      partial(make_integer_plot,
                              lower = tr[["lower"]],
                              upper = tr[["upper"]],
                              caption = tr[["caption"]])
                  } else {
                      stop(sprintf("wrong type, dummy; got %s", t))
                  }
             ## TODO only continuous plots can be split (for now)
             list(f = wrap_split_maybe(name, f), df = tr[["df"]])
         } else if (vartype == "categorical") {
             list(f = make_categorical_plot, df = df)
         } else {
             stop(sprintf("wrong plot type, dummy; got %s", vartype))
         }
    p <- r$f(r$df, name)
    cat(sprintf("## %s\n", name))
    print(p)
    cat("\n\n")
}

walk(univariate, ~ print_uv_plot(.x$meta$vartype, .x$df, .x$meta$name))

```

# Bivariate plots

```{r, echo = FALSE, results = "asis", fig.width = 8, fig.height = 4}

cont_cont_plot <- function(df, yvar, left_name, right_name) {
    # poor-mans 2d step heatmap plot thing
    df %>%
        group_by(right_value) %>%
        mutate(left_upper = lead(left_value)) %>%
        ungroup() %>%
        group_by(left_value) %>%
        mutate(right_upper = lead(right_value)) %>%
        ungroup() %>%
        filter(!is.na(left_upper)) %>%
        filter(!is.na(right_upper)) %>%
        ggplot() +
        geom_rect(aes_string(xmin = "left_value",
                             xmax = "left_upper",
                             ymin = "right_value",
                             ymax = "right_upper",
                             fill = yvar)) +
        xlab(left_name) +
        ylab(right_name) +
        scale_fill_gradient2(low = "red",
                             mid = "black",
                             high = "green",
                             midpoint = 0)
}

print_cont_cont_plot <- function(df, left_name, right_name) {
    cat("### Scores\n\n")
    print(cont_cont_plot(df, "score", left_name, right_name))
    cat("\n\n")
    cat("### Stdevs\n\n")
    print(cont_cont_plot(df, "stdev", left_name, right_name))
}

print_cont_cat_plot_inner <- function(df, cat_name, cont_name) {
    cat_val <- as.character(df$c[[1]])
    tr <- truncate_maybe(df, cont_name)
    t <- get_plot_type(cont_name)
    f <- if (t == "step") {
             partial(make_continuous_plot, caption = tr[["caption"]])
         } else if (t == "bar") {
             partial(make_integer_plot,
                     lower = tr[["lower"]],
                     upper = tr[["upper"]],
                     caption = tr[["caption"]])
         } else {
             stop(sprintf("wrong plot type: got %s", t))
         }
    p <- wrap_split_maybe(cont_name, f)(tr[["df"]], cont_name)
    cat(sprintf("### %s = %s\n\n", cat_name, cat_val))
    print(p)
    cat("\n\n")
}

print_cont_cat_plot <- function(df, cat, cont, cat_name, cont_name) {
    ## this 'all_of' thing is needed to silence a weird warning about
    ## using vectors to select things (I disagree with it, but whatever)
    .df <- rename(df, value = all_of(cont), c = all_of(cat)) %>%
        mutate(lower = score - stdev,
               upper = score + stdev) %>%
        group_split(c) %>%
        walk(~ print_cont_cat_plot_inner(.x, cat_name, cont_name))
}

print_cat_cat_plot <- function(df, left_name, right_name) {
    p <- ggplot(df, aes(factor(left_value),
                         score,
                         fill = factor(right_value)
                         )) +
        geom_col(position = "dodge") +
        geom_errorbar(aes(ymin = score - stdev,
                          ymax = score + stdev),
                      width = 0.1,
                      position = position_dodge(0.9)) +
        xlab(left_name) +
        scale_fill_discrete(name = right_name)
    print(p)
}

print_bv_plot_inner <- function(L, R, df) {
    if (L$type == "continuous" && R$type == "continuous") {
        print_cont_cont_plot(df, L$name, R$name)
    } else if (L$type == "categorical" && R$type == "continuous") {
        print_cont_cat_plot(df, "left_value", "right_value", L$name, R$name)
    } else if (L$type == "continuous" && R$type == "categorical") {
        print_cont_cat_plot(df, "right_value", "left_value", R$name, L$name)
    } else if (L$type == "categorical" && R$type == "categorical") {
        print_cat_cat_plot(df, L$name, R$name)
    } else {
        sprintf("Types are wrong, dummy: %s and/or %s", L$type, R$type)
    }
}

print_bv_plot <- function(L, R, df) {
    cat(sprintf("## %s x %s\n\n", L$name, R$name))

    print_bv_plot_inner(L, R, df)

    cat("\n\n")
}

if (length(bivariate) == 0) {
    cat("None\n\n")
} else {
    walk(bivariate, ~ print_bv_plot(.x$left, .x$right, .x$df))
}

```
