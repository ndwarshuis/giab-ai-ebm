from more_itertools import unzip
from pathlib import Path
from snakemake.utils import min_version, validate

min_version("6.12")


configfile: "config/static.yml"
configfile: "config/dynamic.yml"


# TODO this might make more sense to include in the run_ebm script
def validate_interactions(config):
    def assert_present(run_name, feature_list, ints):
        for i in ints:
            assert (
                i in feature_list
            ), "Interaction %s not found in feature set for run %s" % (
                i,
                run_name,
            )

    for run_name, run_values in config["ebm_runs"].items():
        if "interactions" in run_values and isinstance(
            run_values["interactions"], list
        ):
            for ints in run_values["interactions"]:
                assert_present(run_name, list(run_values["features"]), ints)


def validate_inputs(config):
    inputs = set(config["inputs"])
    for k, v in config["ebm_runs"].items():
        assert set(j for i in v["inputs"] for j in i) <= inputs, (
            "Run config %s contains invalid input keys" % k
        )


validate(config, "schemas/config-schema.yml")
validate_inputs(config)
validate_interactions(config)


################################################################################
# paths

# this is necessary as envs are apparently resolved locally in each rule file
envs_dir = Path("workflow/envs").resolve()
scripts_dir = Path("workflow/scripts").resolve()

conf_paths = config["paths"]
resources_dir = Path(conf_paths["resources"])
results_dir = Path(conf_paths["results"])

################################################################################
# import subworkflows


include: "rules/annotations/get_annotations.smk"
include: "rules/labels/get_labels.smk"
include: "rules/run_ebm.smk"


################################################################################
# main target


rule all:
    input:
        rules.all_summary.input,
        rules.all_ebm.input,
