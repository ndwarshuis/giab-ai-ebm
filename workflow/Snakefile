from more_itertools import unzip
from pathlib import Path
from snakemake.utils import min_version, validate

min_version("6.12")


configfile: "config/static.yml"
configfile: "config/dynamic.yml"


# TODO this might make more sense to include in the run_ebm script
def validate_interactions(config):
    def assert_present(run_name, feature_list, ints):
        for i in ints:
            assert (
                i in feature_list
            ), "Interaction %s not found in feature set for run %s" % (
                i,
                run_name,
            )

    for run_name, run_values in config["ebm_runs"].items():
        if "interactions" in run_values and isinstance(
            run_values["interactions"], list
        ):
            for ints in run_values["interactions"]:
                assert_present(run_name, list(run_values["features"]), ints)


validate(config, "schemas/config-schema.yml")
validate_interactions(config)


################################################################################
# paths

# this is necessary as envs are apparently resolved locally in each rule file
envs_dir = Path("workflow/envs").resolve()

conf_paths = config["paths"]
resources_dir = Path(conf_paths["resources"])
results_dir = Path(conf_paths["results"])

################################################################################
# import subworkflows


include: "rules/download_resources.smk"
include: "rules/annotations/get_annotations.smk"
include: "rules/label_vcf.smk"
include: "rules/run_ebm.smk"


################################################################################
# main target

run_keys, input_keys, filter_keys = unzip(
    [
        (k, i, f)
        for k, v in config["ebm_runs"].items()
        for f in v["filter"]
        for i in v["inputs"]
    ]
)


rule all:
    input:
        expand(
            rules.train_ebm.output,
            zip,
            run_key=[*run_keys],
            input_key=[*input_keys],
            filter_key=[*filter_keys],
        ),
